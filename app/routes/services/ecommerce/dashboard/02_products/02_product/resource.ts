/**
 * Dashboard E-Commerce Product CU Route. For multiple products CU, refer to bulk route /dashboard/ecommerce/products/resource
 * /dashboard/ecommerce/products/:productSlug/resource
 * Only multiple DELETE is supported in bulk route.
 *
 * Load products for Linked Products selection
 */
import type { Route } from './+types/resource'

import type { MaybeArray } from 'date-fns'
import { createSelectSchema } from 'drizzle-zod'
import z from 'zod'

import { seo } from '~/lib/db/schema'
import type { ActionResponse } from '~/lib/utils'
import { handleError } from '~/lib/utils/server'
import { validateAdminSession } from '~/routes/papa/auth/utils'

import {
	createProduct,
	getProducts,
	updateProduct,
} from '../../../lib/db/product.server'
import {
	ecBrand,
	ecCategory,
	ecTag,
	product,
	productAttribute,
	ProductAttributeSelectType,
	productCrossSell,
	productGallery,
	productOption,
	ProductStatus,
	productUpsell,
	productVariant,
	ProductVisibility,
	StockStatus,
} from '../../../lib/db/schema'

// --- Insert/Update Schemas
const insertUpdateProductOptionSchema = createSelectSchema(
	productOption,
).extend({
	price: z.coerce.bigint(),
	salePrice: z.coerce.bigint().nullable(),
	saleStartsAt: z.coerce.date().nullable(),
	saleEndsAt: z.coerce.date().nullable(),
	stockStatus: z.enum(StockStatus),
	createdAt: z.coerce.date(),
	updatedAt: z.coerce.date(),
})
const insertUpdateCategorySchema = createSelectSchema(ecCategory)
const insertUpdateTagSchema = createSelectSchema(ecTag)
const insertUpdateBrandSchema = createSelectSchema(ecBrand)
const insertUpdateVariantSchema = createSelectSchema(productVariant).extend({
	option: insertUpdateProductOptionSchema,
})
const insertUpdateAttributeSchema = createSelectSchema(productAttribute)
	.extend({
		selectType: z.enum(ProductAttributeSelectType),
	})
	.omit({ productId: true }) // Frontend does not set productId for attributes
const insertUpdateGallerySchema = createSelectSchema(productGallery)
const insertUpdateCrossSellSchema = createSelectSchema(productCrossSell).omit({
	productId: true, // Frontend only receive details of other product
	id: true,
})
const insertUpdateUpsellSchema = createSelectSchema(productUpsell).omit({
	productId: true, // Frontend only receive details of other product
	id: true,
})
const insertUpdateSeoSchema = createSelectSchema(seo)
	.extend({
		createdAt: z.coerce.date(),
		updatedAt: z.coerce.date(),
	})
	.omit({
		autoGenerated: true,
		id: true,
	})
	.required({
		metaTitle: true,
		metaDescription: true,
		keywords: true,
		ogImage: true,
		route: true,
	})

const insertUpdateSchema = createSelectSchema(product).extend({
	status: z.enum(ProductStatus),
	visibility: z.enum(ProductVisibility),
	option: insertUpdateProductOptionSchema,
	categories: z.array(insertUpdateCategorySchema),
	tags: z.array(insertUpdateTagSchema),
	brands: z.array(insertUpdateBrandSchema),
	variants: z.array(insertUpdateVariantSchema),
	attributes: z.array(insertUpdateAttributeSchema),

	gallery: z.array(insertUpdateGallerySchema),
	crossSellProductIds: z.array(insertUpdateCrossSellSchema),
	upsellProductIds: z.array(insertUpdateUpsellSchema),
	seo: insertUpdateSeoSchema,

	createdAt: z.coerce.date(),
	updatedAt: z.coerce.date(),
	publishedAt: z.coerce.date().nullable(),
	deletedAt: z.coerce.date().nullable(),
})

export const action = async ({ request }: Route.ActionArgs) => {
	const { user } = await validateAdminSession(request)

	const jsonData = await request.json()

	switch (request.method) {
		case 'POST':
			try {
				console.time('insert:insertUpdateSchema.parse')
				const newProductData = insertUpdateSchema.parse(jsonData)
				console.timeEnd('insert:insertUpdateSchema.parse')

				if (newProductData.status === ('TRASHED' as ProductStatus)) {
					newProductData.deletedAt = new Date()
				} else if (
					newProductData.status &&
					(['PUBLISHED', 'SCHEDULED'] as MaybeArray<ProductStatus>).includes(
						newProductData.status as ProductStatus,
					)
				) {
					if (!newProductData.publishedAt)
						newProductData.publishedAt = new Date()
				} else {
					newProductData.deletedAt = null
					newProductData.publishedAt = null
				}

				await createProduct(newProductData)

				return {
					msg: `Product ${newProductData.name} created successfully`,
				} satisfies ActionResponse
			} catch (error) {
				return handleError(error, request)
			}
		case 'PUT':
			try {
				console.time('update:insertUpdateSchema.parse')
				const updatedProductData = insertUpdateSchema.parse(jsonData)
				console.timeEnd('update:insertUpdateSchema.parse')

				if (updatedProductData.status === ('TRASHED' as ProductStatus)) {
					updatedProductData.deletedAt = new Date()
				} else if (
					updatedProductData.status &&
					(['PUBLISHED', 'SCHEDULED'] as MaybeArray<ProductStatus>).includes(
						updatedProductData.status as ProductStatus,
					)
				) {
					if (!updatedProductData.publishedAt)
						updatedProductData.publishedAt = new Date()
				} else {
					updatedProductData.deletedAt = null
					updatedProductData.publishedAt = null
				}

				await updateProduct(updatedProductData)

				return {
					msg: `Product ${updatedProductData.name} updated successfully`,
				} satisfies ActionResponse
			} catch (error) {
				return handleError(error, request)
			}
		default:
			throw new Response('Method Not Allowed', { status: 405 })
	}
}

export const loader = async ({ request }: Route.LoaderArgs) => {
	const url = new URL(request.url)
	const { searchParams } = url
	const categories = searchParams.get('category')?.split(',')
	const tags = searchParams.get('tag')?.split(',')
	const brands = searchParams.get('brand')?.split(',')
	const attributes = searchParams.get('attribute')?.split(',')
	const title = searchParams.get('q') || undefined

	const products = await getProducts({
		categories,
		tags,
		brands,
		attributes,
		title,
	})

	return { products }
}
