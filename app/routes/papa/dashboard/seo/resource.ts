import { type ActionFunctionArgs } from 'react-router'

import { z } from 'zod'

import { createSEO, deleteSEO, updateSEO } from '~/lib/db/seo.server'
import { type ActionResponse } from '~/lib/utils'
import { handleError } from '~/lib/utils/server'

import { validateAdminSession } from '../../auth/utils'

const insertSchmea = z.object({
	metaTitle: z.string(),
	metaDescription: z.string(),
	keywords: z.string(),
	route: z.string(),
	ogImage: z.string(),
})

const updateSchmea = z.object({
	id: z.string().transform(val => Number(val)),
	metaTitle: z.string(),
	metaDescription: z.string(),
	keywords: z.string(),
	route: z.string(),
	ogImage: z.string(),
})

export const action = async ({ request }: ActionFunctionArgs) => {
	if (!['POST', 'PUT', 'DELETE'].includes(request.method)) {
		return {
			err: 'Method not allowed',
		} satisfies ActionResponse
	}

	await validateAdminSession(request)

	const formData = await request.formData()
	const seoRequested = Object.fromEntries(formData)

	switch (request.method) {
		case 'POST':
			try {
				const seoToCreate = insertSchmea.parse(seoRequested)
				const { seo } = await createSEO({
					metaTitle: seoToCreate.metaTitle,
					metaDescription: seoToCreate.metaDescription,
					route: seoToCreate.route,
					keywords: seoToCreate.keywords,
					ogImage: seoToCreate.ogImage,
					autoGenerated: false,
				})
				return {
					msg: `SEO for ${seo.route || seo.metaTitle || 'unknown'} created`,
				} satisfies ActionResponse
			} catch (error) {
				return handleError(error, request)
			}
		case 'PUT':
			try {
				const seoToUpdate = updateSchmea.parse(seoRequested)
				const { seo } = await updateSEO({
					id: seoToUpdate.id,
					metaTitle: seoToUpdate.metaTitle,
					metaDescription: seoToUpdate.metaDescription,
					route: seoToUpdate.route,
					keywords: seoToUpdate.keywords,
					ogImage: seoToUpdate.ogImage,
				})
				return {
					msg: `SEO for ${seo.route || seo.metaTitle || 'unknown'} updated`,
				} satisfies ActionResponse
			} catch (error) {
				return handleError(error, request)
			}
		case 'DELETE':
			try {
				const id = seoRequested.id
				if (!Number.isNaN(id)) {
					const { seo } = await deleteSEO(Number(id))
					return {
						msg: `SEO for ${seo.route || seo.metaTitle || 'unknown'} delete`,
					} satisfies ActionResponse
				} else {
					throw new Error('Invalid arguments')
				}
			} catch (error) {
				return handleError(error, request)
			}
	}
}
